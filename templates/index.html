<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zensar AI Resume Formatter</title>
    <!-- Futuristic Fonts + Professional Body Font -->
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Inter:wght@300;400;500;600&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css">
    <!-- Docx Preview Library -->
    <script src="https://unpkg.com/jszip/dist/jszip.min.js"></script>
    <script src="https://unpkg.com/docx-preview/dist/docx-preview.min.js"></script>
</head>

<body>

    <!-- Fission Background -->
    <canvas id="fissionCanvas"></canvas>

    <div class="overlay"></div>

    <div class="container">
        <div class="card glass-panel">
            <div class="logo-area">
                <div class="nucleus-icon">âš›</div>
                <h1>Zensar AI <span class="highlight">Resume Formatter</span></h1>
            </div>

            <p class="subtitle">Next-Gen Resume Transformation System</p>

            <div class="upload-area" id="drop-zone">
                <div class="reactor-ring"></div>
                <span class="icon-upload">ðŸ“‚</span>
                <span class="upload-label">Initiate Sequence<br><small>Drop PDF or Click to Upload</small></span>
                <input type="file" id="file-input" accept=".pdf" style="display: none;">
                <div class="file-info" id="file-info"></div>
            </div>

            <button class="convert-btn" id="convert-btn">
                <span class="btn-text">ACTIVATE FISSION</span>
                <span class="btn-glare"></span>
            </button>

            <div class="status-monitor" id="status-monitor" style="display: none;">
                <div class="status-bar">
                    <div class="status-fill" id="status-fill"></div>
                </div>
                <p id="status-text">INITIALIZING CORE...</p>
            </div>

            <div class="result-section" id="result-section">
                <h3><span class="check-icon">âœ“</span> SYSTEM STABLE</h3>
                <p>Resume Generated Successfully.</p>

                <div class="actions">
                    <a href="#" class="download-link" id="download-btn">DOWNLOAD DOCX</a>
                    <button class="preview-toggle" id="preview-toggle">TOGGLE PREVIEW</button>
                    <a href="/" class="reset-link">RESET SYSTEM</a>
                </div>
            </div>
        </div>

        <div id="preview-container" class="preview-container glass-panel" style="display:none;">
            <div class="preview-header">
                <h4>DOCUMENT PREVIEW</h4>
                <button id="close-preview">Ã—</button>
            </div>
            <div id="doc-preview"></div>
        </div>
    </div>

    <script>
        // --- FISSION ANIMATION ENGINE ---
        const canvas = document.getElementById('fissionCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let particles = [];
        let state = 'IDLE'; // IDLE, CRITICAL, STABLE

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = width / 2;
                this.y = height / 2;
                this.angle = Math.random() * Math.PI * 2;
                this.velocity = Math.random() * 0.5 + 0.1;
                this.radius = Math.random() * 2 + 0.5;
                this.life = Math.random() * 100 + 50;
                this.color = `hsla(${Math.random() * 60 + 180}, 100%, 50%, 0.5)`; // Cyan/Blue base

                if (state === 'CRITICAL') {
                    this.velocity = Math.random() * 5 + 2;
                    this.color = `hsla(${Math.random() * 60 + 10}, 100%, 60%, 0.8)`; // Orange/Red
                    this.radius = Math.random() * 4 + 1;
                }
            }

            update() {
                this.x += Math.cos(this.angle) * this.velocity;
                this.y += Math.sin(this.angle) * this.velocity;
                this.life--;

                if (state === 'IDLE') {
                    // Swirling effect
                    this.angle += 0.02;
                    this.velocity *= 0.99; // Damping
                    if (this.velocity < 0.2) this.reset();
                } else if (state === 'CRITICAL') {
                    // Explosion effect
                    this.velocity *= 1.02; // Acceleration
                }

                if (this.life <= 0 || this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.reset();
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                // Glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
            }
        }

        function initParticles(count) {
            particles = [];
            for (let i = 0; i < count; i++) {
                particles.push(new Particle());
            }
        }

        function animate() {
            // Trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Draw Core
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, state === 'CRITICAL' ? 40 : 20, 0, Math.PI * 2);
            ctx.fillStyle = state === 'CRITICAL' ? '#ff4800' : '#00f3ff';
            ctx.shadowBlur = state === 'CRITICAL' ? 50 : 20;
            ctx.shadowColor = state === 'CRITICAL' ? '#ff4800' : '#00f3ff';
            ctx.fill();

            requestAnimationFrame(animate);
        }

        initParticles(200);
        animate();


        // --- LOGIC ---

        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const fileInfo = document.getElementById('file-info');
        const convertBtn = document.getElementById('convert-btn');
        const statusMonitor = document.getElementById('status-monitor');
        const statusText = document.getElementById('status-text');
        const statusFill = document.getElementById('status-fill');
        const resultSection = document.getElementById('result-section');
        const downloadBtn = document.getElementById('download-btn');
        const previewContainer = document.getElementById('preview-container');
        const docPreview = document.getElementById('doc-preview');
        const previewToggle = document.getElementById('preview-toggle');
        const closePreview = document.getElementById('close-preview');

        let selectedFile = null;

        // Drag & Drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

        ['dragenter', 'dragover'].forEach(() => dropZone.classList.add('highlight'));
        ['dragleave', 'drop'].forEach(() => dropZone.classList.remove('highlight'));

        dropZone.addEventListener('drop', handleDrop);
        dropZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFiles);

        function handleDrop(e) { handleFiles({ target: { files: e.dataTransfer.files } }); }

        function handleFiles(e) {
            if (e.target.files.length > 0) {
                selectedFile = e.target.files[0];
                if (selectedFile.type !== 'application/pdf') {
                    alert('CRITICAL ERROR: INVALID FUEL TYPE. PDF REQUIRED.');
                    return;
                }
                fileInfo.textContent = `[LOADED]: ${selectedFile.name}`;
                fileInfo.style.display = 'block';
                convertBtn.style.display = 'flex';
                resultSection.style.display = 'none';

                // Trigger minor visual reaction
                state = 'IDLE';
                initParticles(300);
            }
        }

        convertBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            // UI Transition
            convertBtn.style.display = 'none';
            dropZone.style.display = 'none';
            statusMonitor.style.display = 'block';
            state = 'CRITICAL'; // Trigger Animation

            const formData = new FormData();
            formData.append('file', selectedFile);

            try {
                const response = await fetch('/convert', { method: 'POST', body: formData });
                const data = await response.json();

                if (data.task_id) {
                    pollStatus(data.task_id);
                } else if (data.error) {
                    throw new Error(data.error);
                }
            } catch (error) {
                alert('REACTION FAILED: ' + error.message);
                resetSystem();
            }
        });

        async function pollStatus(taskId) {
            let progress = 0;
            const interval = setInterval(async () => {
                try {
                    const res = await fetch(`/status/${taskId}`);
                    const data = await res.json();

                    // Artificial progress for visuals
                    progress += 5;
                    if (progress > 90) progress = 90;
                    statusFill.style.width = `${progress}%`;

                    if (data.status === 'Completed' && data.download_url) {
                        clearInterval(interval);
                        finishSequence(data.download_url);
                    } else if (data.status && data.status.startsWith('Error')) {
                        clearInterval(interval);
                        alert(data.status);
                        resetSystem();
                    } else {
                        statusText.innerText = (data.status || "PROCESSINGCORE...").toUpperCase();
                    }
                } catch (e) { console.error(e); }
            }, 800);
        }

        async function finishSequence(downloadUrl) {
            state = 'STABLE'; // Calm animation
            statusMonitor.style.display = 'none';
            resultSection.style.display = 'block';
            downloadBtn.href = downloadUrl;

            // Auto-load preview
            try {
                const res = await fetch(downloadUrl);
                const blob = await res.blob();
                renderPreview(blob);
                previewContainer.style.display = 'flex';
            } catch (e) {
                console.error("Preview failed", e);
            }
        }

        function renderPreview(blob) {
            docx.renderAsync(blob, docPreview, null, {
                inWrapper: false,
                ignoreWidth: false,
                ignoreHeight: false,
                ignoreFonts: false,
                breakPages: true,
                debug: false,
                experimental: false,
                className: "docx-wrapper",
                trimXmlDeclaration: true
            }).then(() => {
                console.log("docx: finished rendering");
            });
        }

        previewToggle.addEventListener('click', () => {
            previewContainer.style.display = 'flex';
        });

        closePreview.addEventListener('click', () => {
            previewContainer.style.display = 'none';
        });

        function resetSystem() {
            state = 'IDLE';
            location.reload();
        }

    </script>
</body>

</html>